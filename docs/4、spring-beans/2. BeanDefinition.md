# BeanDefinition系列
Spring对所有对象Bean的抽象及管理，那么Spring就得知道这些Bean有哪些属性，有什么依赖等信息，这些信息就被定义为 `BeanDefinition`。
如XML中的以下配置：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">
        <!-- c这个bean的属性和依赖配置 -->
    </bean>

    <bean id="..." class="...">
        <!-- c这个bean的属性和依赖配置 -->
    </bean>
</beans>
```
上面的每个 `<bean>` 节点都是一个 `BeanDefinition`。

它包含以下元数据。
* 一个全路径类名：通常，被定义的Bean的实际实现类。
* Bean的行为配置元素，它说明了Bean在容器中的行为方式（scope、生命周期回调，等等）。
* 对其他Bean的引用，这些Bean需要做它的工作。这些引用也被称为合作者或依赖。
* 要在新创建的对象中设置的其他配置设置，例如，pool的大小限制或在管理连接池的Bean中使用的连接数。

## UML
```plantuml
interface BeanDefinition
interface AnnotatedBeanDefinition
class ScannedGenericBeanDefinition
class AnnotatedGenericBeanDefinition
abstract AbstractBeanDefinition
class RootBeanDefinition
class ChildBeanDefinition
class GenericBeanDefinition

BeanDefinition <|-- AnnotatedBeanDefinition
BeanDefinition <|-- AbstractBeanDefinition
AnnotatedBeanDefinition <|-- ScannedGenericBeanDefinition
AnnotatedBeanDefinition <|-- AnnotatedGenericBeanDefinition
AbstractBeanDefinition <|-- RootBeanDefinition
AbstractBeanDefinition <|-- ChildBeanDefinition
AbstractBeanDefinition <|-- GenericBeanDefinition
GenericBeanDefinition <|-- ScannedGenericBeanDefinition
GenericBeanDefinition <|-- AnnotatedGenericBeanDefinition
```

一个Bean有一个标识符，多个别名。

### 别名的使用
例如，子系统A的配置元数据可以引用一个名为 subsystemA-dataSource 的数据源。  
子系统B的配置元数据可以引用一个名为 subsystemB-dataSource 的数据源。  
当组成使用这两个子系统的主应用程序时，主应用程序以 myApp-dataSource 的名字来引用数据源。  
为了让这三个名字都指代同一个对象，你可以在配置元数据中添加以下别名定义。
```xml
<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
<alias name="myApp-dataSource" alias="subsystemB-dataSource"/>
```
现在，每个组件和主应用程序都可以通过一个独特的名称来引用dataSource，并保证不与任何其他定义冲突（有效地创建了一个命名空间），但它们引用的是同一个bean。

### Bean的实例化
#### 用构造函数进行实例化
```xml
<bean id="exampleBean" class="examples.ExampleBean"/>
```
#### 用静态工厂方法进行实例化
```java
public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}
```
```xml
<bean id="clientService"
    class="examples.ClientService"
    factory-method="createInstance"/>
```
#### 用实例工厂方法进行实例化
```java
public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}
```
```xml
<bean id="serviceLocator" class="examples.DefaultServiceLocator"/>

<bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/>
```

## Bean Scope
现有6个，也可自定义。

| Scope       | 说明                            |
|-------------|-------------------------------|
| singleton   | （默认）单例，Spring容器里只有一个实例        |
| prototype   | 多例，每次使用时创建一个                  |
| request     | 每个HTTP请求使用同一个。Web场景有效         |
| session     | 每个HTTP Session请求使用同一个。Web场景有效 |
| application | 每个ServletContext使用同一个。Web场景有效 |
| websocket   | 每个ServletContext使用同一个。Web场景有效 |

一般来说无状态的Bean使用单例，有状态的Bean使用多例。而且Spring不管理多例Bean的完整生命周期（比如：初始化生命周期回调方法在所有对象上被调用，但在prototype的情况下，配置的销毁生命周期回调不会被调用）。
