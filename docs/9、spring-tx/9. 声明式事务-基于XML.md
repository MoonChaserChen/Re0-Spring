# 声明式事务-基于XML
## 一、使用示例
### 1) DB准备
```mysql
create table pet (
    id bigint unsigned not null comment '主键',
    pet_name varchar(22) comment '宠物名',
    age int unsigned comment '宠物年龄',
    primary key (id)
) comment '宠物表';
```
### 2) Service准备
这里直接使用JDBC，不使用其它持久层框架。
```java
public class PetService {
    public static final String STUB_INSERT = "insert into pet values (1, 'Tom', 18)";

    private DataSource dataSource;

    public DataSource getDataSource() {
        return dataSource;
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public void stubInsert() {
        // 这里不能直接使用 dataSource.getConnection()，将导致多个sql使用的不是同一个 Connection，无法回滚
        // 不能关闭Connection，因为下个sql还会用到这个Connection，Spring会在commit或rollback时自动关闭。那单独使用这个方法就会导致Connection无法关闭么？而且如果使用了Mybatis等，它会自动关闭Connection吗？
        try {
            Connection con = DataSourceUtils.getConnection(dataSource);
            PreparedStatement ps = con.prepareStatement(STUB_INSERT);
            ps.execute();
            ps.execute(); // Duplicate entry '1' for key 'pet.PRIMARY'
        } catch (CannotGetJdbcConnectionException | SQLException e) {
            throw new RuntimeException(e);
        }
    }
}
```
### 3) 事务相关Bean配置
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!--DataSource-->
    <bean id="dataSource" class="com.mysql.cj.jdbc.MysqlDataSource">
        <property name="user" value="root"/>
        <property name="url" value="jdbc:mysql://localhost:3306/akira?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false"/>
        <property name="password" value="root@Mysql8.0"/>
    </bean>

    <!--TransactionManager-->
    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--TransactionAdvice-->
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <tx:attributes>
            <tx:method name="get*" read-only="true"/>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <!--Service(AOP Target)-->
    <bean id="petService" class="ink.akira.spring.jdbc.PetService">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--AOP-->
    <aop:config>
        <aop:pointcut id="petServiceOperation"  expression="execution(* ink.akira.spring.jdbc.PetService.stubInsert(..))"/>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="petServiceOperation"/>
    </aop:config>
</beans>
```

### 4) 测试
```java
public class TransactionTest {
    @Test(expected = RuntimeException.class)
    public void test3() {
        BeanFactory beanFactory = new ClassPathXmlApplicationContext("spring-bean4.xml");
        PetService petService = beanFactory.getBean("petService", PetService.class);
        petService.stubInsert();
    }
}
```

## 二、实现原理
基于AOP实现的，Advice为 `org.springframework.transaction.interceptor.TransactionInterceptor`。 `TransactionInterceptor` 是由 `TxAdviceBeanDefinitionParser` 解析成 `BeanDefinition` 而后再创建的。
### TxAdviceBeanDefinitionParser
将 `<tx:advice>` 解析成 BeanDefinition 并依此创建 Bean。 参考 [BeanDefinitionParser](../4、spring-beans/8.%20BeanDefinitionParser.md)

```java
class TxAdviceBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {
    @Override
    protected Class<?> getBeanClass(Element element) {
        return TransactionInterceptor.class;
    }
    
    // ------------------
    // other code ignored
    // ------------------
}
```

### TransactionInterceptor逻辑
核心逻辑位于 `TransactionInterceptor` 的父类 `TransactionAspectSupport` 中。
```java
public abstract class TransactionAspectSupport implements BeanFactoryAware, InitializingBean {
    protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,
                                             final InvocationCallback invocation) throws Throwable {
        // ------------------
        // other code ignored
        // ------------------
        try {
            // 执行原方法
            retVal = invocation.proceedWithInvocation();
        } catch (Throwable ex) {
            // 有异常就回滚
            completeTransactionAfterThrowing(txInfo, ex);
            throw ex;
        } finally {
            // 没异常就提交
            cleanupTransactionInfo(txInfo);
        }

        commitTransactionAfterReturning(txInfo);
        return retVal;
    }
    // ------------------
    // other code ignored
    // ------------------
}
```
简单来说就是使用Around切面，在原方法的执行上加上try-catch-finally，如果有异常就回滚，没有异常就提交。
#### 回滚条件
虽说在 `TransactionAspectSupport` 里如果有异常就会执行 `completeTransactionAfterThrowing`，但并非所有情况都会回滚。其逻辑如下：
```java
public abstract class TransactionAspectSupport implements BeanFactoryAware, InitializingBean {
    protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {
        if (txInfo != null && txInfo.getTransactionStatus() != null) {
            // ------------------
            // code simplified
            // ------------------
            if (txInfo.transactionAttribute != null && txInfo.transactionAttribute.rollbackOn(ex)) {
                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());
            } else {
                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
            }
        }
        // ------------------
        // other code ignored
        // ------------------
    }
}
```
也就是具体看 `txInfo.transactionAttribute.rollbackOn(ex)` 的计算结果会不会回滚。逻辑如下：
```java
public class RuleBasedTransactionAttribute extends DefaultTransactionAttribute implements Serializable {
    @Override
    public boolean rollbackOn(Throwable ex) {
        RollbackRuleAttribute winner = null;
        int deepest = Integer.MAX_VALUE;

        if (this.rollbackRules != null) {
            for (RollbackRuleAttribute rule : this.rollbackRules) {
                int depth = rule.getDepth(ex);
                if (depth >= 0 && depth < deepest) {
                    deepest = depth;
                    winner = rule;
                }
            }
        }

        // User superclass behavior (rollback on unchecked) if no rule matches.
        if (winner == null) {
            return super.rollbackOn(ex);
        }

        return !(winner instanceof NoRollbackRuleAttribute);
    }
}
```
也就是看 `rollback-for` 指定的异常（还可以通过depth检查inner Exception）。在没有指定 `rollback-for` 的情况下，默认是 `RuntimeException` 或 `Error` 才会回滚。
```java
public class DefaultTransactionAttribute extends DefaultTransactionDefinition implements TransactionAttribute {
    @Override
    public boolean rollbackOn(Throwable ex) {
        return (ex instanceof RuntimeException || ex instanceof Error);
    }   
}
```
#### 手动指定rollback-for
```xml
<tx:advice id="txAdvice" transaction-manager="txManager">
    <tx:attributes>
        <tx:method name="get*" read-only="true"/>
        <tx:method name="*" rollback-for="java.lang.Exception"/>
    </tx:attributes>
</tx:advice>
```