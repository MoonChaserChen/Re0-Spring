# 模块说明
默认情况捕获到RuntimeException或Error时回滚，而捕获到编译时异常不回滚。可通过rollbackFor指定
## Spring事务管理的方式
1.编程式事务：在代码中硬编码（不推荐使用）。
2.声明式事务：在配置文件中配置（推荐使用），分为基于XML的声明式事务和基于注解的声明式事务。
## Spring事务传播行为
事务的传播行为是指：多个事务方法相互调用时,事务如何在这些方法间传播。Spring中默认的传播行为是 Propagation.REQUIRED。可以手动指定其他的事务传播行为，如下：

| 传播行为 | 说明 |
| ---- | ---- |
| Propagation.MANDATORY | 如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。 |
| Propagation.REQUIRED | 如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。 |
| Propagation.REQUIRES_NEW | 重新创建一个新的事务，如果当前存在事务，则挂起已存在的事务直到此方法结束。 |
| Propagation.NESTED | 如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务。 |
| Propagation.SUPPORTS | 如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。 |
| Propagation.NOT_SUPPORTED |  以非事务的方式运行，如果当前存在事务，则挂起已存在的事务直到此方法结束。 |
| Propagation.NEVER | 以非事务的方式运行，如果当前存在事务，则抛出异常。 |

## @Transactional生效条件
1. @Transactional注解只能应用到public修饰符上，其它修饰符不起作用，但不报错
2. @Transactional注释的方法，必须是有接口的方法实现（待确认）
3. @Transactional注释的方法，必须要通过接口的方式调用，才能生效（待确认）
4. 本类中非事务方法调用事务方法，即使在事务方法中出异常，不回滚
   > 可使用AopContext.currentProxy()来获取代理类再调用
5. 异步线程中抛异常，不回滚
6. DB本身不支持事务（例如Mysql的MyISAM引擎）
> 使用 AspectJ 取代 Spring AOP 代理方式也可以解决上面非public和类内部方法调用事务不生效的问题