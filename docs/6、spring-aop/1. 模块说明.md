# 模块说明
AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，
便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。
## Spring AOP与动态代理
Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。
默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。
### jdk动态代理的局限
因为jdk代理是 基于接口的动态代理技术，由于接口的方法都必然是public的，这就要求实现类的实现方法也必须是public的，同时不能使用static的修饰符。
所以，可以实施jdk动态代理的方法只能使用public或public final修饰符的方法，其他方法不可能被动态代理，相应的也就不能实施AOP增强，换句话，即不能进行spring 增强了。
### Cglib动态代理的局限
基于Cglib字节码动态代理是通过扩展被增强类，动态创建其子类的方式进行AOP增强植入的。由于使用final、static、private修饰符的方法不能被子类覆盖，相应的，这些方法就无法实施AOP增强。

## Spring AOP和AspectJ AOP
Spring AOP是属于运行时增强，而AspectJ是编译时增强。Spring AOP基于代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）。
AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；
第二种方式是类加载期织入，也简称为LTW（Load Time Weaving）
Spring AOP已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。
如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它比SpringAOP快很多。

| Spring AOP                 | AspectJ AOP                             |
|----------------------------|-----------------------------------------|
| 在纯 Java 中实现                | 使用 Java 编程语言的扩展实现                       |
| 不需要单独的编译过程                 | 除非设置 LTW，否则需要 AspectJ 编译器 (ajc)         |
| 只能使用运行时织入                  | 运行时织入不可用。支持编译时、编译后和加载时织入                |
| 功能不强-仅支持方法级编织              | 更强大 - 可以编织字段、方法、构造函数、静态初始值设定项、最终类/方法等…。 |
| 只能在由 Spring 容器管理的 bean 上实现 | 可以在所有域对象上实现                             |
| 仅支持方法执行切入点                 | 支持所有切入点                                 |
| 代理是由目标对象创建的, 并且切面应用在这些代理上  | 在执行应用程序之前 (在运行时) 前, 各方面直接在代码中进行织入       |
| 比 AspectJ 慢多了              | 更好的性能                                   |
| 易于学习和应用                    | 相对于 Spring AOP 来说更复杂                    |